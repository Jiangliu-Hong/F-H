<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>弗兰克—赫兹实验 · FH.html（锁定画布 1280×640 · 紫色闪光 5 帧淡出 · 可调播放速度）</title>
  <style>
    :root { --bg:#000; --text:#e5e7eb; }
    *{box-sizing:border-box}
    body{margin:0;padding:16px;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,"Microsoft YaHei",Arial,sans-serif}
    h1{font-size:18px;margin:0 0 12px}
    .wrap{display:grid;grid-template-columns:auto 360px;gap:16px;align-items:start}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.12);border-radius:14px}
    .canvas-card{padding:12px;position:relative;width:1304px;overflow:auto}
    canvas{width:1280px;height:640px;display:block;background:#000;border-radius:10px}
    .hud{position:absolute;left:16px;top:12px;padding:8px 10px;border-radius:8px;background:rgba(0,0,0,.35);backdrop-filter:blur(4px);font-size:12px;line-height:1.35}
    .panel{padding:14px}
    .row{margin:10px 0 14px}
    .row label{display:flex;justify-content:space-between;font-size:13px;color:#9ca3af;margin-bottom:6px}
    .row output{color:#e5e7eb;font-variant-numeric:tabular-nums;margin-left:8px;min-width:90px;text-align:right}
    input[type=range]{width:100%;appearance:none;height:6px;border-radius:999px;background:rgba(255,255,255,.14);outline:none}
    input[type=range]::-webkit-slider-thumb{appearance:none;width:16px;height:16px;border-radius:50%;background:#38bdf8;border:2px solid #fff;cursor:pointer}
    .btns{display:flex;gap:8px;flex-wrap:wrap;margin-top:4px}
    button{padding:8px 10px;border:1px solid rgba(255,255,255,.16);border-radius:10px;background:#0e1623;color:#e5e7eb;cursor:pointer;font-size:13px}
    button.primary{background:#112133;border-color:rgba(56,189,248,.35);color:#e6f7ff}
    .legend{font-size:12px;color:#9ca3af;margin-top:6px}
    .badge{display:inline-block;padding:2px 6px;border-radius:999px;border:1px solid rgba(255,255,255,.2);margin-right:6px}
    .hr{height:1px;background:rgba(255,255,255,.08);margin:10px 0;border-radius:999px}
  </style>
</head>
<body>
  <h1>弗兰克—赫兹实验 · 浏览器模拟（总能量阈值 · Va 左侧 · Vr 匀场 · 栅极通过率 · 5 帧紫色闪光淡出）</h1>
  <div class="wrap">
    <div class="card canvas-card">
      <div class="hud" id="hud">
        Va=<b id="hudVa">5.0</b> V　Vr=<b id="hudVr">2.0</b> V　Pg=<b id="hudPg">50%</b><br/>
        本帧到达板极：<b id="hudHit">0</b>　管内：<b id="hudAlive">0</b>
        I=<b id="hudI">0.00 pA</b>
      </div>
      <canvas id="cv" width="1280" height="640"></canvas>
    </div>
    <div class="row">
      <label>工作气体 <output id="oGas">Hg</output></label>
      <select id="gas">
        <option value="Hg" selected>Hg（汞）</option>
        <option value="Ar">Ar（氩）</option>
        <option value="Ne">Ne（氖）</option>
      </select>
    </div>
    <div class="card panel">
      <div class="row">
        <label>Va · 加速电压（0–30 V）<output id="oVa">5.0 V</output></label>
        <input id="va" type="range" min="0" max="40" value="2" step="0.1"/>
      </div>
      <div class="row">
        <label>Vr · 拒斥电压（0–10 V）<output id="oVr">2.0 V</output></label>
        <input id="vr" type="range" min="0" max="10" value="2" step="0.1"/>
      </div>
      <div class="row">
        <label>Pg · 栅极通过率（20–100%）<output id="oPg">50%</output></label>
        <input id="pg" type="range" min="20" max="100" value="50" step="1"/>
      </div>
      <div class="row">
        <label>每帧发射电子数 <output id="oEmit">18</output></label>
        <input id="emit" type="range" min="2" max="60" value="2" step="1"/>
      </div>
      <div class="row">
        <label>温度 T（1000–3000 K）<output id="oTemp">2000 K</output></label>
        <input id="temp" type="range" min="1000" max="3000" value="2500" step="10"/>
      </div>

      <div class="row">
        <label>播放速度（每帧延迟）<output id="oDelay">0 ms</output></label>
        <input id="delay" type="range" min="0" max="30" value="5" step="1"/>
      </div>

      <div class="row">
        <label>显示轨迹长度（帧）<output id="oTrail">0</output></label>
        <input id="trail" type="range" min="0" max="120" value="0" step="5"/>
      </div>
      <div class="btns">
        <button class="primary" id="btnToggle">暂停</button>
        <button id="btnReset">复位</button>
        <button id="btnClearTrail">清轨迹</button>
      </div>
      <div class="hr"></div>
      <div class="legend">
        <span class="badge" style="border-color:#111;color:#ddd">黑点：电子</span>
        <span class="badge" style="border-color:#800080;color:#c4b5fd">紫色星形：非弹性碰撞（5 帧淡出）</span>
        <span class="badge">Va/Vr 与底部电路标注同步</span>
      </div>
    </div>
  </div>

<script>
// ===== 常量 =====
const l0=2000.0,l1=40000.0,l2=10000.0,d0=6000.0;
const ll=2*l0 + l1 + l2;
const lll = l0 + l1;
let e_nec=4.95;
const v2e=593084.0,dt=9e-5;
const xGrid=l0+l1,xAnode=l0+l1+l2;
const T0=1900;
const GRID_KILL_DIST=l0*0.05, GRID_KILL_SPEED=v2e*0.015;
const GAS = {
  Hg: { E: 4.9,  color: '#800080' }, // 紫
  Ar: { E: 11.6, color: '#ff0000' }, // 红
  Ne: { E: 16.6, color: '#ffa500' }, // 橙
};

// ★ 新增(电流)：电荷常数、窗口平均
const E_CHARGE = 1.602176634e-19;            // C
const CURRENT_WIN_FRAMES = 100;              // 平滑窗口长度（帧）
let hitWindow = new Array(CURRENT_WIN_FRAMES).fill(0);
let hitIndex = 0, totalHitsInWindow = 0;
let I_inst_A = 0, I_avg_A = 0;
let framesFilled = 0;  // 新增：窗口已填充的有效帧数（<= CURRENT_WIN_FRAMES）

// —— 胶囊几何（绘制 & 碰撞共用，确保物理边界一致）——
const END_AR = 1.65;           // 横向拉长比例（>1 更扁）
const yTop = 0, yBottom = d0;
const yc = (yTop + yBottom)/2;
const ry = (yBottom - yTop)/2; // 垂直半轴
let rx = ry * END_AR;          // 水平半轴
rx = Math.min(rx, (ll)/2 - 1e-6);
const cxL = 0  + rx;           // 左端半椭圆中心
const cxR = ll - rx;           // 右端半椭圆中心
const EPS_INSIDE = 1e-6*Math.max(rx,ry); // 入内微移
// 给定 y，返回左右边界 x 值
function leftBoundaryX(y){
  const t = (y - yc)/ry;
  const s2 = Math.max(0, 1 - t*t);
  return cxL - rx*Math.sqrt(s2);
}
function rightBoundaryX(y){
  const t = (y - yc)/ry;
  const s2 = Math.max(0, 1 - t*t);
  return cxR + rx*Math.sqrt(s2);
}

// 椭圆隐式函数：在cx为中心、半轴rx,ry的椭圆外？
function outsideEllipse(xi, yi, cx) {
  const dx = (xi - cx) / rx;
  const dy = (yi - yc) / ry;
  return dx*dx + dy*dy > 1 + 1e-12; // 加一点容差更稳
}

// 直线反射（y=const），并推进到腔体内一点
function reflectOnHorizontal(i, yBoundary, isTop) {
  y[i] = isTop ? (yBoundary + EPS_INSIDE) : (yBoundary - EPS_INSIDE);
  vy[i] = isTop ? Math.abs(vy[i]) : -Math.abs(vy[i]);
}

// 椭圆法线反射（以 F= (x-cx)^2/rx^2 + (y-yc)^2/ry^2 -1 的 ∇F 为法线）
function reflectOnEllipse(i, cx){
  const yv = Math.min(Math.max(y[i], yTop), yBottom);
  // 边界点 (xb, yv)：同 y 的椭圆交点（左或右已在外面判断）
  let xb;
  if (cx === cxL){ xb = leftBoundaryX(yv); }
  else           { xb = rightBoundaryX(yv); }

  // 法线方向（未归一）
  let nx = (xb - cx)/(rx*rx);
  let ny = (yv - yc)/(ry*ry);
  const nlen = Math.hypot(nx, ny) || 1;
  nx /= nlen; ny /= nlen;              // n̂

  // 速度镜面反射
  const vdotn = vx[i]*nx + vy[i]*ny;
  vx[i] = vx[i] - 2*vdotn*nx;
  vy[i] = vy[i] - 2*vdotn*ny;

  // 把粒子放回腔体内一点点（沿内法线方向）
  x[i] = xb - nx*EPS_INSIDE;
  y[i] = yv - ny*EPS_INSIDE;
}

// —— 热分布 —— 
const kB_eVK=8.617333262e-5;
function thermalSigmaFromTeff(T){ return v2e*Math.sqrt(0.5*kB_eVK*Math.max(T,0)); }
function randn(){ let u=0,v=0; while(!u)u=Math.random(); while(!v)v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }

// ===== UI / HUD =====
const cv=document.getElementById('cv'); const ctx=cv.getContext('2d');
const $va=va,$vr=vr,$pg=pg,$emit=emit,$trail=trail,$temp=temp,$delay=delay;
const $oVa=oVa,$oVr=oVr,$oPg=oPg,$oEmit=oEmit,$oTrail=oTrail,$oTemp=oTemp,$oDelay=oDelay;
const $hudVa=hudVa,$hudVr=hudVr,$hudPg=hudPg,$hudHit=hudHit,$hudAlive=hudAlive;
const $hudI = document.getElementById('hudI');


function formatCurrent(I){
  const a = Math.abs(I);
  if (a >= 1)      return I.toFixed(3)   + ' A';
  if (a >= 1e-3)   return (I*1e3).toFixed(2)  + ' mA';
  if (a >= 1e-6)   return (I*1e6).toFixed(2)  + ' μA';
  if (a >= 1e-9)   return (I*1e9).toFixed(2)  + ' nA';
  if (a >= 1e-12)  return (I*1e12).toFixed(2) + ' pA';
  return (I*1e15).toFixed(2) + ' fA';
}

function syncHUD(){
  $oVa.textContent=(+$va.value).toFixed(1)+" V"; $hudVa.textContent=(+$va.value).toFixed(1);
  $oVr.textContent=(+$vr.value).toFixed(1)+" V"; $hudVr.textContent=(+$vr.value).toFixed(1);
  $oPg.textContent=(+$pg.value).toFixed(0)+"%";  $hudPg.textContent=(+$pg.value).toFixed(0)+"%";
  $oEmit.textContent=$emit.value; $oTrail.textContent=$trail.value;
  $oTemp.textContent=(+$temp.value|0)+" K"; $oDelay.textContent=(+$delay.value|0)+" ms";
}
[$va,$vr,$pg,$emit,$trail,$temp,$delay].forEach(el=>el.addEventListener('input', syncHUD)); syncHUD();

// ===== 坐标映射 =====
const marginL = 5*l0, marginR = 5*l0 + l2, marginBottom = 4*l0, marginTop = l0;
const xMM = x => (x + marginL) * (cv.width  / (ll + marginL + marginR));
const yMM = y => (d0 + marginTop - y) * (cv.height / (d0 + marginTop + marginBottom));
function strokeLine(x1,y1,x2,y2,color='#fff',lw=2){ ctx.strokeStyle=color; ctx.lineWidth=lw; ctx.beginPath(); ctx.moveTo(xMM(x1),yMM(y1)); ctx.lineTo(xMM(x2),yMM(y2)); ctx.stroke(); }

// 胶囊外形（绘制专用；左端角度顺序照你的要求）
function stadiumPath(ctx, x1, x2, yTop, yBottom, segments = 64){
  const step = Math.PI/segments;
  ctx.beginPath();
  // 顶边：左上切点 → 右上切点
  ctx.moveTo(xMM(cxL), yMM(yTop));
  ctx.lineTo(xMM(cxR), yMM(yTop));

  // 右端：从上到下（-π/2 → +π/2）
  for (let a = -Math.PI/2; a <= Math.PI/2; a += step){
    const xx = cxR + rx*Math.cos(a);
    const yy = yc  + ry*Math.sin(a);
    ctx.lineTo(xMM(xx), yMM(yy));
  }

  // 底边：右下 → 左下
  ctx.lineTo(xMM(cxL), yMM(yBottom));

  // 左端：从上到下（+π/2 → +3π/2）——与你给的顺序完全一致
  for (let a = Math.PI/2; a <= 3*Math.PI/2; a += step){
    const xx = cxL + rx*Math.cos(a);
    const yy = yc  + ry*Math.sin(a);
    ctx.lineTo(xMM(xx), yMM(yy));
  }
  ctx.closePath();
}

// ===== 粒子与火花 =====
let x=[],y=[],vx=[],vy=[],flash=[],trails=[];
const MAXP=20000;

// 火花（5 帧淡出，位置固定）
const SPARK_TTL = 20;
let STAR_COLOR  = '#800080';
const BASE_FILL_A = 0.25;
let sparks = []; // {x,y,life}
const $gas = document.getElementById('gas');
const $oGas = document.getElementById('oGas');
function applyGas(kind){
  const g = GAS[kind] || GAS.Hg;
  e_nec = g.E;
  STAR_COLOR = g.color;
  if ($oGas) $oGas.textContent = kind;
}
if ($gas){
  $gas.addEventListener('input', e => applyGas(e.target.value));
  applyGas($gas.value); // 初始化
}
function emitElectrons(n){
  const T=+$temp.value; if(T<T0) return;
  const sig=thermalSigmaFromTeff(T-T0);
  for(let i=0;i<n;i++){
    x.push(l0);
    y.push(d0/6 + Math.random()*(d0*2/3));
    vx.push(sig*randn()); vy.push(sig*randn());
    flash.push(0); trails.push([]);
  }
}
function removeAt(i){ x.splice(i,1); y.splice(i,1); vx.splice(i,1); vy.splice(i,1); flash.splice(i,1); trails.splice(i,1); }

function step(Va,Vr,trailLen){
  let hits=0; const xPrev=x.slice();

  // 推进
  for(let i=0;i<x.length;i++){ x[i]+=vx[i]*dt; y[i]+=vy[i]*dt; }

  // —— 壁反射：上/下直线；左/右半椭圆 —— //
  // === 用这段替换 step()里 的“壁反射”块 ===
  for (let i = 0; i < x.length; i++) {
    const xi = x[i], yi = y[i];

    // 分区：只在中段用顶/底线；左右端只用椭圆
    if (xi >= cxL && xi <= cxR) {
      // 中段：上下直线边界
      if (yi <= yTop) {
        reflectOnHorizontal(i, yTop, /*isTop=*/true);
      } else if (yi >= yBottom) {
        reflectOnHorizontal(i, yBottom, /*isTop=*/false);
      }
    } else if (xi < cxL) {
      // 左端：仅椭圆
      if (outsideEllipse(xi, yi, cxL)) {
        reflectOnEllipse(i, cxL);
      }
    } else { // xi > cxR
      // 右端：仅椭圆
      if (outsideEllipse(xi, yi, cxR)) {
        reflectOnEllipse(i, cxR);
      }
    }
  }

  // 栅极通过率（双向）
  const passProb=Math.max(0.2,Math.min(1.0,+$pg.value/100));
  if(passProb<1){
    const rm=[]; const eps=1e-9;
    for(let i=0;i<x.length;i++){
      const crossedLR=(xPrev[i]+eps)<xGrid && (x[i]-eps)>=xGrid;
      const crossedRL=(xPrev[i]-eps)>xGrid && (x[i]+eps)<=xGrid;
      if(crossedLR||crossedRL){ if(Math.random()>passProb) rm.push(i); }
    }
    if(rm.length){ rm.sort((a,b)=>b-a); for(const i of rm) removeAt(i); }
  }

  // Va 左侧加速
  const ax_va=0.5*v2e*v2e*(+Va)/l1;
  for(let i=0;i<x.length;i++){ if(x[i]<xGrid&& x[i]>l0) vx[i]+=ax_va*dt; }

  // Vr 右侧匀场减速
  const ax_vr=-0.5*v2e*v2e*(+Vr)/l2;
  for(let i=0;i<x.length;i++){ if(x[i]>xGrid && x[i]<xAnode) vx[i]+=ax_vr*dt; }

  // 左侧区非弹性碰撞（总能量阈值）
  for(let i=0;i<x.length;i++){
    const eTot=(vx[i]/v2e)**2 + (vy[i]/v2e)**2;
    if(x[i]<=xGrid && eTot>=e_nec){
      const p=Math.min(0.4,Math.max(0.1,0.10+0.15*(eTot-e_nec)/(e_nec+1e-6)));
      if(Math.random()<p){
        const Eafter=Math.max(eTot-e_nec,0.1*eTot);
        const s=v2e*Math.sqrt(Eafter), th=Math.random()*2*Math.PI;
        vx[i]=s*Math.cos(th); vy[i]=s*Math.sin(th);
        sparks.push({x:x[i], y:y[i], life:SPARK_TTL}); // 火花固定位置
        flash[i]=SPARK_TTL;
      }
    }else if(x[i]<=xGrid && eTot<e_nec){
      if(x[i]>l0+0.05*l1 && x[i]<l0+0.4*l1 && Math.random()<0.01){
        const sp=Math.hypot(vx[i],vy[i]); const th=Math.random()*2*Math.PI;
        vx[i]=sp*Math.cos(th); vy[i]=sp*Math.sin(th);
      }
    }
  }

  // 栅极近且慢删除
  for(let i=x.length-1;i>=0;i--){
    if(Math.abs(x[i]-xGrid)<=GRID_KILL_DIST){
      const speed=Math.hypot(vx[i],vy[i]);
      if(speed<GRID_KILL_SPEED) removeAt(i);
    }
  }

  // 轨迹
  for(let i=0;i<trails.length;i++){
    if(i>=x.length) break;
    if(+trailLen>0){ trails[i].push([x[i],y[i]]); if(trails[i].length>+trailLen) trails[i].shift(); }
    else trails[i].length=0;
  }

  // 命中/越界
  for(let i=x.length-1;i>=0;i--){
    if(x[i]>=xAnode){ hits++; removeAt(i); continue; }
    if(x[i]<-l0 || y[i]<-d0 || y[i]>2*d0){ removeAt(i); }
  }

  // 火花寿命减 1（5 帧淡出）
  for(let i=sparks.length-1;i>=0;i--){
    sparks[i].life -= 1;
    if(sparks[i].life<=0) sparks.splice(i,1);
  }

  // 软上限
  if(x.length>MAXP){
    const idx=[...x.keys()];
    for(let i=idx.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [idx[i],idx[j]]=[idx[j],idx[i]]; }
    const keep=new Set(idx.slice(0,MAXP));
    for(let i=x.length-1;i>=0;i--){ if(!keep.has(i)) removeAt(i); }
  }
  return hits;
}

// ===== 绘制参数 =====
const DOT_R = 1.2;
const STAR_R_OUT = 6;
const STAR_R_IN  = STAR_R_OUT*0.45;
const STAR_POINTS = 5;
const STAR_LINEW = 2;

function drawStar(px, py, alpha){
  const step = Math.PI / STAR_POINTS;

  // 尺度随透明度缩小：alpha=1 时原大小，→0 时收拢到 0
  const rOut = STAR_R_OUT * alpha;
  const rIn  = STAR_R_IN  * alpha;

  ctx.save();
  ctx.beginPath();
  for(let i=0;i<2*STAR_POINTS;i++){
    const r = (i%2===0) ? rOut : rIn;
    const a = -Math.PI/2 + i*step;
    const x = px + r*Math.cos(a);
    const y = py + r*Math.sin(a);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath();

  // 填充与描边仍按颜色与 alpha 渐隐
  ctx.globalAlpha = 0.25 * alpha;      // 基准填充透明度 × 渐隐
  ctx.fillStyle = STAR_COLOR;
  ctx.fill();

  ctx.globalAlpha = alpha;             // 描边按 alpha 渐隐
  ctx.lineWidth = STAR_LINEW;
  ctx.strokeStyle = STAR_COLOR;
  ctx.stroke();
  ctx.restore();
}
// —— 顶部电势轴（0V@灯丝 → VaV@栅极）——
function niceStep(maxV, targetTicks=6){
  if (maxV <= 0) return 1;
  const raw = maxV/targetTicks;
  const pow = Math.pow(10, Math.floor(Math.log10(raw)));
  const cand = [1,2,5].map(k=>k*pow);
  for (const s of cand){ if (raw <= s) return s; }
  return 10*pow;
}
function drawPotentialAxis(Va){
  const yAxis = d0 + 0.3*marginTop; // 顶部空间内
  const xL = l0, xR = xGrid;

  // 轴线
  strokeLine(xL, yAxis, xR, yAxis, '#fff', 2);

  // 刻度与标签
  ctx.fillStyle='#fff'; ctx.font='12px ui-sans-serif'; ctx.textAlign='center'; ctx.textBaseline='top';

  if (Va <= 0){
    // 0V 情况：只标 0V
    strokeLine(l0, yAxis-8, l0, yAxis+8, '#fff', 2);
    ctx.fillText('0 V', xMM(l0), yMM(yAxis) + 6);
    return;
  }

  const step = niceStep(Va, 6);
  for (let v=0; v<=Va+1e-9; v+=step){
    const xv = l0 + (v/Va) * l1; // 线性映射到灯丝→栅极距离
    strokeLine(xv, yAxis-8, xv, yAxis+8, '#fff', 2);
    ctx.fillText(`${Math.round(v*10)/10} V`, xMM(xv), yMM(yAxis)+6);
  }
  // 端点标签（确保 Va 精确显示）
  strokeLine(xR, yAxis-10, xR, yAxis+10, '#fff', 2);
  ctx.fillText(`${(+va.value).toFixed(1)} V`, xMM(xR), yMM(yAxis)+6);

  // 轴标题
  ctx.textBaseline='alphabetic'; ctx.font='13px ui-sans-serif';
  ctx.fillText('电势 (V)', (xMM(xL)+xMM(xR))/2, yMM(yAxis)-12);
}


// ===== 绘制 =====
function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);

  // 胶囊腔体（白底 + 灰填充 + 白描边）
  stadiumPath(ctx, 0, ll, 0, d0);
  ctx.fillStyle = '#fff'; ctx.fill();
  stadiumPath(ctx, 0, ll, 0, d0);
  ctx.fillStyle = 'rgba(160,160,160,0.30)'; ctx.fill();
  stadiumPath(ctx, 0, ll, 0, d0);
  ctx.lineWidth = 6; ctx.strokeStyle = '#fff'; ctx.stroke();

  // 红色灯丝（波形）
  ctx.strokeStyle='#e11d48'; ctx.lineWidth=2;
  const N=100; ctx.beginPath();
  for(let i=0;i<N;i++){
    const yv=d0/6 + (d0*4/6)*(i/(N-1));
    const xv=l0 + 100*Math.sin(yv/100);
    const px=xMM(xv), py=yMM(yv); if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
  }
  ctx.stroke();

  // 栅极虚线
  ctx.save(); ctx.setLineDash([10,6]); strokeLine(xGrid,0,xGrid,d0,'#fff',3); ctx.restore();

  // 右极板
  strokeLine(xAnode, d0/12, xAnode, d0*11/12, '#bfbfbf', 3);

  // 轨迹（可选）
  if (+$trail.value>0){
    ctx.lineWidth=1.2; ctx.strokeStyle='rgba(0,0,0,0.25)';
    for (let i=0;i<trails.length;i++){
      if (i>=x.length) break;
      const tr = trails[i];
      if (tr.length>1){
        ctx.beginPath();
        for (let k=0;k<tr.length;k++){
          const px=xMM(tr[k][0]), py=yMM(tr[k][1]);
          if(k===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.stroke();
      }
    }
  }

  // 电子
  for (let i=0;i<x.length;i++){
    const px=xMM(x[i]), py=yMM(y[i]);
    if (DOT_R<=1.1) { ctx.fillStyle='#000'; ctx.fillRect(px,py,1,1); }
    else { ctx.beginPath(); ctx.arc(px,py,DOT_R,0,Math.PI*2); ctx.fillStyle='#000'; ctx.fill(); }
  }

  // 火花（淡出）
  for (let i=0;i<sparks.length;i++){
    const s = sparks[i];
    const alpha = Math.max(0, s.life / SPARK_TTL);
    drawStar(xMM(s.x), yMM(s.y), alpha);
  }
  // 顶部电势轴（改动②）
  drawPotentialAxis(+$va.value);
  // 下方电路与标注（保持你当前版）
  const yBase=-d0*5/15;
  strokeLine(-2*l0, d0/6,   l0,     d0/6,   '#fff',2);
  strokeLine(-2*l0, d0*5/6, l0,     d0*5/6, '#fff',2);
  strokeLine(-2*l0, d0*5/6, -2*l0,  d0*22/42,'#fff',2);
  strokeLine(-l0*2 - d0*1/15, d0*22/42, -l0*2 + d0*1/15, d0*22/42, '#fff',2);
  strokeLine(-l0*2 - d0*3/15, d0*20/42, -l0*2 + d0*3/15, d0*20/42, '#fff',2);
  strokeLine(-2*l0, d0*20/42, -2*l0, d0/6, '#fff',2);

  strokeLine(0, 0, 0, yBase, '#fff',2);
  strokeLine(0, yBase, 6/15*lll, yBase, '#fff',2);
  strokeLine(6/15*lll, yBase - d0*0.5/15, 6/15*lll, yBase + d0*0.5/15, '#fff',2);
  strokeLine(19/45*lll, yBase - d0*1.5/15, 19/45*lll, yBase + d0*1.5/15, '#fff',2);
  strokeLine(19/45*lll, yBase, 7/15*lll, yBase, '#fff',2);
  strokeLine(7/15*lll,  yBase, lll + 1/7*l2 + 1/45*lll, yBase, '#fff',2);

  strokeLine(xGrid, yBase, xGrid, 0, '#fff',2);

  strokeLine(lll, yBase, lll, 0, '#fff',2);
  strokeLine(lll + 1/7*l2 + 1/45*lll,           yBase - d0*1.5/15,
             lll + 1/7*l2 + 1/45*lll,           yBase + d0*1.5/15, '#fff',2);
  strokeLine(lll + 1/7*l2 + 1/45*lll + 1/45*lll, yBase - d0*0.5/15,
             lll + 1/7*l2 + 1/45*lll + 1/45*lll, yBase + d0*0.5/15, '#fff',2);
  strokeLine(lll + 1/7*l2 + 1/45*lll + 1/45*lll,
             yBase,
             lll + 1/7*l2 + 1/45*lll + 1/45*lll + 1/15*lll,
             yBase, '#fff',2);
  strokeLine(lll + 1/7*l2 + 1/45*lll + 2/15*lll,
             yBase,
             xAnode,
             yBase, '#fff',2);
  strokeLine(xAnode, yBase, xAnode, 0.8/12*d0, '#fff',2);

  strokeLine(4/15*lll, -d0*2.5/15, 7.5/15*lll, -d0*2.5/15, '#fff',2);
  strokeLine(4/15*lll, -d0*5/15, 4/15*lll, -d0*2.5/15, '#fff',2);
  strokeLine(8.5/15*lll,-d0*2.5/15,11/15*lll, -d0*2.5/15, '#fff',2);
  strokeLine(11/15*lll,-d0*5/15, 11/15*lll, -d0*2.5/15, '#fff',2);

  function ellipse(cx,cy,rx,ry,lw=3,color='#fff'){
    ctx.beginPath(); ctx.lineWidth=lw; ctx.strokeStyle=color;
    ctx.ellipse(xMM(cx), yMM(cy), (xMM(cx+rx)-xMM(cx)), Math.abs(yMM(cy-ry)-yMM(cy)), 0, 0, Math.PI*2); ctx.stroke();
  }
  ellipse(8/15*lll, -2.5/15*d0, 1/30*lll, (1/15*lll*0.4)/2, 3, '#fff');
  ellipse(lll + 1/7*l2 + 2/45*lll + 1.5/15*lll, -5/15*d0, 1/30*lll, (1/15*lll*0.4)/2, 3, '#fff');

  ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='16px ui-sans-serif';
  ctx.fillText('V', xMM(8/15*lll), yMM(-2.5/15*d0));
  ctx.fillText('A', xMM(lll + 1/7*l2 + 2/45*lll + 1.5/15*lll), yMM(-5/15*d0));
  ctx.textBaseline='alphabetic'; ctx.font='14px ui-sans-serif';
  ctx.fillText(`${(+va.value).toFixed(0)}V`, xMM(6.5/15*lll), yMM(-5.7/15*d0));
  ctx.fillText(`${(+vr.value).toFixed(0)}V`, xMM(xGrid),       yMM(-5.7/15*d0));
  //ctx.fillText(`0.0`, xMM(xAnode + 0.02*lll), yMM(-5.7/15*d0));
  ctx.fillText(`${formatCurrent(I_avg_A)}`, xMM(xAnode + 0.02*lll), yMM(-5.7/15*d0));
}

// ===== 调度 =====
let running=true, rafId=null, timerId=null;
function scheduleNext(){ if(!running) return; const d=+$delay.value; if(d>0){ timerId=setTimeout(()=>{ rafId=requestAnimationFrame(frame); }, d); } else { rafId=requestAnimationFrame(frame); } }
function frame(){
  if(!running) return;
  emitElectrons(+$emit.value);
  const hits=step(+$va.value,+$vr.value,+$trail.value);
  // ★ 新增(电流)：即时与窗口平均
  // 即时电流
  I_inst_A = hits * E_CHARGE / dt;

  // 窗口更新（环形缓冲）
  totalHitsInWindow += hits - hitWindow[hitIndex];
  hitWindow[hitIndex] = hits;
  if (framesFilled < CURRENT_WIN_FRAMES) framesFilled++;
  hitIndex = (hitIndex + 1) % CURRENT_WIN_FRAMES;

  // 平均电流：窗口未满用 framesFilled 作分母
  I_avg_A = (totalHitsInWindow * E_CHARGE) / (framesFilled * dt);


  draw();
  hudHit.textContent=hits; hudAlive.textContent=x.length;
  if ($hudI) $hudI.textContent = formatCurrent(I_avg_A);
  scheduleNext();
}
btnToggle.addEventListener('click', ()=>{
  running=!running; btnToggle.textContent = running ? '暂停' : '继续';
  if (running){ scheduleNext(); } else { if(rafId){cancelAnimationFrame(rafId); rafId=null;} if(timerId){clearTimeout(timerId); timerId=null;} }
});
btnReset.addEventListener('click', ()=>{
  x.length=y.length=vx.length=vy.length=flash.length=trails.length=0; sparks.length=0;
  hitWindow.fill(0); hitIndex=0; totalHitsInWindow=0;
  framesFilled = 0;  // 新增
  I_inst_A=0; I_avg_A=0;
  if ($hudI) $hudI.textContent='0.00 pA';
  if(rafId){cancelAnimationFrame(rafId); rafId=null;} if(timerId){clearTimeout(timerId); timerId=null;}
  if(!running){ running=true; btnToggle.textContent='暂停'; }
});
btnClearTrail.addEventListener('click', ()=>{ for(const tr of trails) tr.length=0; });

// 启动
emitElectrons(12);
scheduleNext();
</script>
</body>
</html>
